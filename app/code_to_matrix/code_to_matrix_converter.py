import numpy as np
from common.logger_util import get_logger
from neo4j.neo4j_client import Neo4JClient
from neo4j.neo4j_container import Neo4JContainer
from code_property_graph_creator import CodePropertyGraphCreator
from node_identity_assigner import NodeIdentityAssigner
from edge_identity_assigner import EdgeIdentityAssigner


# Code to Matrix
class CodeToMatrixConverter:

    def __init__(self, neo4j_config, joern_config, nn_input_size):
        self.__logger = get_logger(__name__)
        self.__node_identity_assigner = NodeIdentityAssigner()
        self.__edge_identity_assigner = EdgeIdentityAssigner()
        self.neo4j_config = neo4j_config
        self.joern_config = joern_config
        self.nn_input_size = nn_input_size

    def convert(self, app_source_location):

        self.__create_code_property_graph(app_source_location)
        self.__run_neo4j_container()

        query_result = self.__execute_neo4j_matrix_query()

        result = self.__process_query_result(query_result)

        return result

    def __create_code_property_graph(self, app_source_location):
        print "code property graph is creating..."
        code_property_graph_creator = CodePropertyGraphCreator(
            neo4j_config=self.neo4j_config,
            joern_config=self.joern_config
        )
        code_property_graph_creator.create(app_source_location)
        print "code property graph is created for %s" % app_source_location

    def __run_neo4j_container(self):
        print "neo4j_container is starting..."
        neo4j_container = Neo4JContainer(self.neo4j_config)
        neo4j_container.run()
        print "neo4j_container is started"

    def __execute_neo4j_matrix_query(self):
        neo4j_client = Neo4JClient(self.neo4j_config)
        return neo4j_client.execute_matrix_query()

    def __process_query_result(self, query_result):

        outer = []

        for i in query_result:
            inner = []

            for j in i:
                if j == 0:
                    inner.append([0, 0, 0])
                else:
                    inner.append(self.__feature_value_calculate(j))

            outer.append(inner)

        return self.__padding(outer)

    def __feature_value_calculate(self, feature):

        node_types = str(feature).split(':')
        if len(node_types) != 3:
            raise Exception("graph node feature not in correct format")

        node_type_0 = node_types[0]
        node_type_1 = node_types[2]

        edge_type = node_types[1]

        node_type_id_0 = self.__node_identity_assigner.save_and_get_node(node_type_0)
        node_type_id_1 = self.__node_identity_assigner.save_and_get_node(node_type_1)

        edge_type_id = self.__edge_identity_assigner.save_and_get_edge(edge_type)

        return [node_type_id_0, edge_type_id, node_type_id_1]

    def __padding(self, matrix):
        np_array = np.array(matrix)
        x, y, _ = np_array.shape

        if self.nn_input_size < x:
            raise Exception("input matrix size must be less than < %d x %d" % (self.nn_input_size, self.nn_input_size))

        # since x and y always same. we use only x
        pad_total = self.nn_input_size - x

        if pad_total == 0:
            pad_1 = 0
            pad_2 = 0
        elif (pad_total % 2) == 0:
            pad_1 = pad_total / 2
            pad_2 = pad_1
        else:

            # eg:
            # pad_total = 5
            # pad_1 = pad_total/2 => 5 / 2 = 2
            # pad_2 = pad_1 + 1 => 2 + 1 = 3
            # pad_total == pad_1 + pad_2
            pad_1 = pad_total / 2
            pad_2 = pad_1 + 1

        return np.pad(np_array, ((pad_1, pad_2), (pad_1, pad_2), (0, 0)), 'constant', constant_values=0)
